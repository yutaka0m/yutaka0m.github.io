<!doctype html><html lang=jp-ja><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=hugo-theme content="Axiom 0.7.0"><link rel=icon href=/image/favicon/favicon.ico><link rel=apple-touch-icon href=/image/brand/icon-1-1.jpg><link rel=canonical href=https://tech.yutaka0m.com/entry/2020/01/25/13/><link rel=preload as=style href="/bundle.css?v=1613305790" media=all><link rel=stylesheet href="/bundle.css?v=1613305790" media=all><style>.cdata pre{color:#edf2f7;background-color:#2d3748}.cdata :not(pre)>code{color:#805ad5;background-color:#f7fafc}.chroma .err{color:#fed7d7;background-color:#9b2c2c}.chroma .hl{background-color:#4a5568}.chroma .ln{color:#a0aec0}.chroma .k,.chroma .kc,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr{color:#63b3ed}.chroma .kt{color:#b794f4}.chroma .na{color:#f6e05e}.chroma .nb{color:#f6ad55}.chroma .nc{color:#fc8181}.chroma .no{color:#68d391}.chroma .nd{color:#fc8181}.chroma .ne{color:#fc8181}.chroma .nf{color:#f6ad55}.chroma .nt{color:#fc8181}.chroma .l{color:#b794f4}.chroma .dl,.chroma .ld,.chroma .s,.chroma .s2,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .sd{color:#68d391}.chroma .se{color:#a0aec0}.chroma .s1,.chroma .sh,.chroma .si,.chroma .sr,.chroma .ss,.chroma .sx{color:#68d391}.chroma .il,.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .mo{color:#b794f4}.chroma .o,.chroma .ow{color:#90cdf4}.chroma .p{color:#cbd5e0}.chroma .c,.chroma .c1,.chroma .ch,.chroma .cm,.chroma .cp,.chroma .cpf,.chroma .cs{color:#a0aec0}.chroma .ge{font-style:italic}.chroma .gs{font-weight:700}</style><title>Kotlinコーディング規約 : yutaka0m blog</title><meta property="og:title" content="Kotlinコーディング規約"><meta property="og:site_name" content="yutaka0m blog"><meta property="og:url" content="https://tech.yutaka0m.com/entry/2020/01/25/13/"><link rel=image_src href=https://tech.yutaka0m.com/image/top-image.jpg><meta property="og:image" content="https://tech.yutaka0m.com/image/top-image.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:type" content="article"><meta property="og:locale" content="jp_ja"><meta property="og:description" content="この記事は http://kotlinlang.org/ のCoding Conventionsを日本語に翻訳したものです。 原文は2020年1月2日時点のものを参照しています。 http://kotlinlang.org/ は Apache License 2.0です。 GitHubには「母国語に翻訳してWebに公開してよい」と記載されています。 コーディング規約 このページでは、Kotlinのための一般的なコーディングスタイルについて紹介します。  ソースコードの構成 命名規則 フォーマット ドキュメントコメント 冗長な構造の回避 Kotlinらしい書き方 ライブラリでのコーディング規約  スタイルガイドを適用する このスタイルガイドと一致するをIntelliJのフォーマッターを設定するには、Kotlin pluginのバージョン1.2.20以降をインストール。Settings -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; Kotlinで、上部右端の**Set from…**をクリック。Predefined style -&amp;gt; Kotlin style guideをメニューから選択します。 コードがスタイルガイドに剃ってフォーマットされていることを確認できます。そのためには、Kotlin-&amp;gt;Style issues-&amp;gt;File is not formatted according to project settingsを有効にします。"><meta name=description content="この記事は http://kotlinlang.org/ のCoding Conventionsを日本語に翻訳したものです。 原文は2020年1月2日時点のものを参照しています。 http://kotlinlang.org/ は Apache License 2.0です。 GitHubには「母国語に翻訳してWebに公開してよい」と記載されています。 コーディング規約 このページでは、Kotlinのための一般的なコーディングスタイルについて紹介します。  ソースコードの構成 命名規則 フォーマット ドキュメントコメント 冗長な構造の回避 Kotlinらしい書き方 ライブラリでのコーディング規約  スタイルガイドを適用する このスタイルガイドと一致するをIntelliJのフォーマッターを設定するには、Kotlin pluginのバージョン1.2.20以降をインストール。Settings -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; Kotlinで、上部右端の**Set from…**をクリック。Predefined style -&amp;gt; Kotlin style guideをメニューから選択します。 コードがスタイルガイドに剃ってフォーマットされていることを確認できます。そのためには、Kotlin-&amp;gt;Style issues-&amp;gt;File is not formatted according to project settingsを有効にします。"><meta property="og:updated_time" content="2020-01-25T08:30:22Z"><meta property="fb:app_id" content><meta name=author content="yutaka0m"><meta property="article:author" content="https://tech.yutaka0m.com"><meta property="article:published_time" content="2020-01-25T08:30:22Z"><meta property="article:modified_time" content="2020-01-25T08:30:22Z"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Kotlinコーディング規約","alternativeHeadline":"この記事は http://kotlinlang.org/ のCoding Conventionsを日本語に翻訳したものです。 原文は2020年1月2日時点のものを参照しています。 http://kotlinlang.org/ は Apache License 2.0です。 GitHubには「母国語に翻訳してWebに公開してよい」と記載されています。 コーディング規約 このページでは、Kotlinのための一般的なコーディングスタイルについて紹介します。  ソースコードの構成 命名規則 フォーマット ドキュメントコメント 冗長な構造の回避 Kotlinらしい書き方 ライブラリでのコーディング規約  スタイルガイドを適用する このスタイルガイドと一致するをIntelliJのフォーマッターを設定するには、Kotlin pluginのバージョン1.2.20以降をインストール。Settings -\u0026gt; Editor -\u0026gt; Code Style -\u0026gt; Kotlinで、上部右端の**Set from…**をクリック。Predefined style -\u0026gt; Kotlin style guideをメニューから選択します。 コードがスタイルガイドに剃ってフォーマットされていることを確認できます。そのためには、Kotlin-\u0026gt;Style issues-\u0026gt;File is not formatted according to project settingsを有効にします。","url":"https://tech.yutaka0m.com/entry/2020/01/25/13/","image":"https://tech.yutaka0m.com/image/top-image.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech.yutaka0m.com/entry/2020/01/25/13/"},"description":"この記事は http://kotlinlang.org/ のCoding Conventionsを日本語に翻訳したものです。 原文は2020年1月2日時点のものを参照しています。 http://kotlinlang.org/ は Apache License 2.0です。 GitHubには「母国語に翻訳してWebに公開してよい」と記載されています。 コーディング規約 このページでは、Kotlinのための一般的なコーディングスタイルについて紹介します。  ソースコードの構成 命名規則 フォーマット ドキュメントコメント 冗長な構造の回避 Kotlinらしい書き方 ライブラリでのコーディング規約  スタイルガイドを適用する このスタイルガイドと一致するをIntelliJのフォーマッターを設定するには、Kotlin pluginのバージョン1.2.20以降をインストール。Settings -\u0026gt; Editor -\u0026gt; Code Style -\u0026gt; Kotlinで、上部右端の**Set from…**をクリック。Predefined style -\u0026gt; Kotlin style guideをメニューから選択します。 コードがスタイルガイドに剃ってフォーマットされていることを確認できます。そのためには、Kotlin-\u0026gt;Style issues-\u0026gt;File is not formatted according to project settingsを有効にします。","author":{"@type":"Person","name":"yutaka0m"},"publisher":{"@type":"Organization","name":"yutaka0m blog","logo":{"@type":"ImageObject","url":"https://tech.yutaka0m.com/image/brand/icon-1-1.jpg"}},"datePublished":"2020-01-25T08:30:22Z","dateModified":"2020-01-25T08:30:22Z","articleBody":"\u003cp\u003eこの記事は \u003ca href=\"http://kotlinlang.org/\"\u003ehttp://kotlinlang.org/\u003c/a\u003e の\u003ca href=\"https://kotlinlang.org/docs/reference/coding-conventions.html\"\u003eCoding Conventions\u003c/a\u003eを日本語に翻訳したものです。\u003cbr\u003e\n原文は2020年1月2日時点のものを参照しています。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://kotlinlang.org/\"\u003ehttp://kotlinlang.org/\u003c/a\u003e は \u003ca href=\"https://github.com/JetBrains/kotlin-web-site/blob/master/LICENSE\"\u003eApache License 2.0\u003c/a\u003eです。\u003cbr\u003e\n\u003ca href=\"https://github.com/JetBrains/kotlin-web-site/blob/master/pages/contribute.md#translations\"\u003eGitHub\u003c/a\u003eには「母国語に翻訳してWebに公開してよい」と記載されています。\u003c/p\u003e\n\u003ch2 id=\"span-idiコーディング規約span\"\u003e\u003cspan id=\"i\"\u003eコーディング規約\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003eこのページでは、Kotlinのための一般的なコーディングスタイルについて紹介します。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eソースコードの構成\u003c/li\u003e\n\u003cli\u003e命名規則\u003c/li\u003e\n\u003cli\u003eフォーマット\u003c/li\u003e\n\u003cli\u003eドキュメントコメント\u003c/li\u003e\n\u003cli\u003e冗長な構造の回避\u003c/li\u003e\n\u003cli\u003eKotlinらしい書き方\u003c/li\u003e\n\u003cli\u003eライブラリでのコーディング規約\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"span-idi-2スタイルガイドを適用するspan\"\u003e\u003cspan id=\"i-2\"\u003eスタイルガイドを適用する\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eこのスタイルガイドと一致するをIntelliJのフォーマッターを設定するには、Kotlin pluginのバージョン1.2.20以降をインストール。\u003cstrong\u003eSettings\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eEditor\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eCode Style\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eKotlin\u003c/strong\u003eで、上部右端の**Set from…**をクリック。\u003cstrong\u003ePredefined style\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eKotlin style guide\u003c/strong\u003eをメニューから選択します。\u003c/p\u003e\n\u003cp\u003eコードがスタイルガイドに剃ってフォーマットされていることを確認できます。そのためには、\u003cstrong\u003eKotlin\u003c/strong\u003e-\u0026gt;\u003cstrong\u003eStyle issues\u003c/strong\u003e-\u0026gt;\u003cstrong\u003eFile is not formatted according to project settings\u003c/strong\u003eを有効にします。\u003c/p\u003e\n\u003cp\u003eスタイルガイドに他の問題（命名規則など）を検討する追加のインスペクションはデフォルトで有効になっています。\u003c/p\u003e\n\u003ch2 id=\"span-idi-3ソースコードの構成span\"\u003e\u003cspan id=\"i-3\"\u003eソースコードの構成\u003c/span\u003e\u003c/h2\u003e\n\u003ch3 id=\"span-idi-4ディレクトリ構造span\"\u003e\u003cspan id=\"i-4\"\u003eディレクトリ構造\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e純粋なKotlinプロジェクトでは、推奨されるディレクトリ構造は共通ルートパッケージが省略したパッケージ構造に従います。たとえば、プロジェクト内のすべてのコードが\u003ccode\u003eorg.example.kotlin\u003c/code\u003eパッケージとそのサブパッケージである場合。\u003ccode\u003eorg.example.kotlin\u003c/code\u003eパッケージを持つファイルは、ソースルート配下におかなければいけません。そして\u003ccode\u003eorg.example.kotlin.network.socket\u003c/code\u003eのファイルはソースルートの\u003ccode\u003enetwork/socket\u003c/code\u003eサブディレクトリにある必要があります。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eJVMにおいて\u003c/em\u003e\u003c/strong\u003e: KotlinがJavaと一緒に使用されるプロジェクトにおいては、Kotlinのソースファイルは、Javaソースファイルと同じソースルートに存在する必要があり、同じディレクトリ構造に従います（それぞれのファイルは、各パッケージ文に対応するディレクトリ内に存在する必要があります。）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"span-idi-5ソースファイル名span\"\u003e\u003cspan id=\"i-5\"\u003eソースファイル名\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eもし、Kotlinファイルに1つのクラスだけが含まれる場合、ファイル名は\u003ccode\u003e.kt\u003c/code\u003e拡張子を加えたクラスメイト同じにしなければいけません。もしファイルに複数のクラスやトップレベル宣言だけの場合、ファイルの内容を説明する適切な名前をつけましょう。最初の文字が大文字のキャメルケースを使ってください（たとえば、\u003ccode\u003eProcessDeclarations.kt\u003c/code\u003e）\u003c/p\u003e\n\u003cp\u003eファイル名はそのファイルの中のコードがやっていること説明する必要があります。それゆえ、\u0026quot;Uitl”のような無意味な言葉を避けるべきです。\u003c/p\u003e\n\u003ch3 id=\"span-idi-6ソースファイル構成span\"\u003e\u003cspan id=\"i-6\"\u003eソースファイル構成\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e宣言に意味的に密接な関係があって、ファイルサイズが適切な範囲内（数百行を超えない）である限り、同一のKotlinソースファイル内に複数の宣言を配置することは推奨されます。\u003c/p\u003e\n\u003cp\u003eとくに、あるクラスのすべてのクライアントに関連する拡張関数を定義するとき、クラス自体が定義されているファイルと同じところに書きます。特定のクライアントに対してのみ意味のある拡張関数を定義する場合、それらをクライアントに続いて記述します。決して、\u0026quot;Fooのすべての拡張子”を持つだけのファイルを作ってはいけない。\u003c/p\u003e\n\u003ch3 id=\"span-idi-7クラスレイアウトspan\"\u003e\u003cspan id=\"i-7\"\u003eクラスレイアウト\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e一般に、クラスの中身は、以下のような順番でソートされている。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eプロパティ宣言とinitializerブロック\u003c/li\u003e\n\u003cli\u003eセカンダリーコンストラクター\u003c/li\u003e\n\u003cli\u003eメソッド宣言\u003c/li\u003e\n\u003cli\u003eコンパニオン　オブジェクト\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eメソッドをアルファベット順や見やすさでソートしないでください、そして、普通のメソッドを拡張メソッドと分けないでください。それよりも、クラスを上から下に読んだとき、何が起きているかを理論的に追うことができるような順番にします。順序を選択し（最初に高レベルのもの、またはその逆）、それを遵守します。\u003c/p\u003e\n\u003cp\u003eネストされたクラスは、そららのクラスを使用するコードの隣に配置します。もしクラスが外部から使用されることが想定され、クラス内で参照されない場合、それは最後（コンパニオンオブジェクトの後ろ）に配置します。\u003c/p\u003e\n\u003ch3 id=\"span-idi-8インタフェース実装レイアウトspan\"\u003e\u003cspan id=\"i-8\"\u003eインタフェース実装レイアウト\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eインタフェースを実装する場合、実装メンバーをインタフェースメンバーと同じ順番にします。\u003c/p\u003e\n\u003ch3 id=\"span-idi-9オーバーロードレイアウトspan\"\u003e\u003cspan id=\"i-9\"\u003eオーバーロードレイアウト\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e常にオーバーロードを隣どうしに配置します。\u003c/p\u003e\n\u003ch2 id=\"span-idi-10命名規則span\"\u003e\u003cspan id=\"i-10\"\u003e命名規則\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003eKotlinにおけるパッケージとクラスの命名ルールはとてもシンプルです。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eパッケージ名は常にローワーケースで、アンダースコアを使用してはいけません（\u003ccode\u003eorg.example.project\u003c/code\u003e）。\u003cbr\u003e\n通常、複数語の名前は推奨されませんが、複数語を使用する必要があるときは、単純にくっつけるかキャメルケースを使用します（\u003ccode\u003eorg.example.myProject\u003c/code\u003e）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eクラスやオブジェクト名は大文字で始めて、キャメルケースを使用します。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eopen class DeclarationProcessor { /*...*/ }\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-11関数名span\"\u003e\u003cspan id=\"i-11\"\u003e関数名\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e関数、プロパティ、ローカル変数の名前は小文字から始まり、キャメルケースを使って、アンダースコアは使ってはいけません。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun processDeclarations() { /*...*/ }\nvar declarationCount = 1\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e例外：インスタンスを生成するファクトリー関数は、作成されるクラスと同じ名前を持つことができます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eabstract class Foo { /*...*/ }\nclass FooImpl : Foo { /*...*/ }\nfun FooImpl(): Foo { return FooImpl() }\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-12テストメソッドの名前span\"\u003e\u003cspan id=\"i-12\"\u003eテストメソッドの名前\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eテストでは、バッククォートで囲われた中では、スペースを含むメソッド名を使用することが許容されます。メソッド名にアンダースコアを使うのもテストコードでは許されます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass MyTestCase {\n     @Test fun \u0026lt;code\u003eensure everything works\u003c/code\u003e() { /*...*/ }\n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}\u0026lt;/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-13プロパティ名span\"\u003e\u003cspan id=\"i-13\"\u003eプロパティ名\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e定数名（\u003ccode\u003econst\u003c/code\u003eでマークされたプロパティ、またはトップレベル、またはイミュータブルなデータを保持するカスタム\u003ccode\u003eget\u003c/code\u003e関数がない\u003ccode\u003eval\u003c/code\u003eプロパティ）。 は大文字のアンダースコアで区切られた名前を使用しなくてはいけません。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003econst val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\"\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eふるまい、または変更可能（ミュータブル）なデータを持つトップレベルかオブジェクトプロパティーの名前は、キャメルケースを使用する必要があります。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eval mutableCollection: MutableSet\u0026lt;String\u0026gt; = HashSet()\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eenum定数の場合、アンダースコアで区切られた大文字（\u003ccode\u003eenum class Color { RED, GREEN }\u003c/code\u003e）か、大文字で始まるキャメルケースを使用できますので、用途に合わせて使ってください。\u003c/p\u003e\n\u003ch4 id=\"バッキングプロパティの名前\"\u003eバッキングプロパティの名前\u003c/h4\u003e\n\u003cp\u003eもしクラス内に、概念的には同じ2つのプロパティで、一方はパブリックなAPIでもう一方は実装の詳細である場合、プライベートプロパティの名前の先頭にアンダースコアをつけることできます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass C {\n    private val _elementList = mutableListOf\u0026lt;Element\u0026gt;()\n    val elementList: List\u0026lt;Element\u0026gt;\n         get() = _elementList\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-14よい名前を選ぶspan\"\u003e\u003cspan id=\"i-14\"\u003eよい名前を選ぶ\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eクラス名は通常クラスが何者であるかを示す名詞か名詞句です：\u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003ePersonReader\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003eメソッド名は通常メソッドが何をするかを述べる動詞か動詞句です:\u003ccode\u003eclose\u003c/code\u003e, \u003ccode\u003ereadPersons\u003c/code\u003e。また名前は、メソッドがオブジェクトを変更するか、新しいオブジェクトを返すかを示す必要があります。たとえば、\u003ccode\u003esort\u003c/code\u003eはコレクションを所定の位置に並び替え、\u003ccode\u003esorted\u003c/code\u003eはコレクションを並び変えたコピーを返します。\u003c/p\u003e\n\u003cp\u003e名前はエンティティ（実態）の目的を明確にする必要があるので、（\u003ccode\u003eManager\u003c/code\u003e, \u003ccode\u003eWrapper\u003c/code\u003e）などの意味のない言葉を使用することを避けるのがベストです。\u003c/p\u003e\n\u003cp\u003e宣言名の一部として頭文字を使用する場合、2文字の場合は大文字にします（\u003ccode\u003eIOStream\u003c/code\u003e）。それ以上の長さの場合は最初の文字だけ大文字にします（\u003ccode\u003eXmlFormatter\u003c/code\u003e, \u003ccode\u003eHttpInputStream\u003c/code\u003e）。\u003c/p\u003e\n\u003ch2 id=\"span-idi-15フォーマットspan\"\u003e\u003cspan id=\"i-15\"\u003eフォーマット\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003eインデントはタブではなく、4文字のスペースを使用します。\u003c/p\u003e\n\u003cp\u003e中カッコは、構造を開始する行の終わりに開き中かっこを配置します。閉じかっこは、かっこの開始行と同じ縦ラインに記述します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eif (elements != null) {\n    for (element in elements) {\n        // ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-16水平の空白span\"\u003e\u003cspan id=\"i-16\"\u003e水平の空白\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e2項演算子のまわりにはスペースを配置します（\u003ccode\u003ea + b\u003c/code\u003e）。例外：\u0026quot;range to\u0026quot;演算子のまわりにはスペースを入れないでください（\u003ccode\u003e0..i\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e単項演算子のまわりにはスペースを入れないでください（\u003ccode\u003ea++\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e制御フローキーワード（\u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003ewhen\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e）の間にスペースと、対応する開きかっこを配置します。\u003c/p\u003e\n\u003cp\u003eプライマリコンストラクター宣言、メソッド宣言、メソッド呼び出しの前開きかっこの前にスペースを入れないでください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass A(val x: Int)\nfun foo(x: Int) { ... }\nfun bar() {\n    foo(1)\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e(\u003c/code\u003e, \u003ccode\u003e[\u003c/code\u003eの後ろ、または\u003ccode\u003e)\u003c/code\u003e, \u003ccode\u003e]\u003c/code\u003eの前にスペースを入れないでください。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.\u003c/code\u003eまたは\u003ccode\u003e?.\u003c/code\u003eのまわりにスペースを入れないでください（\u003ccode\u003efoo.bar().filter { it \u0026gt; 2 }.joinToString()\u003c/code\u003e, \u003ccode\u003efoo?.bar()\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e//\u003c/code\u003eの後ろにスペースを配置します（\u003ccode\u003e// This is a comment\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e型パラメーターを指定するために使う、角かっこのまわりにスペースを入れないでください\u003ccode\u003eclass Map\u0026lt;K, V\u0026gt; { ... }\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e::\u003c/code\u003eのまわりにスペースを入れないでください（\u003ccode\u003eFoo::class\u003c/code\u003e, \u003ccode\u003eString::length\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003enull許容な型を作るときに使われる\u003ccode\u003e?\u003c/code\u003eの前にスペースを入れないでください（\u003ccode\u003eString?\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e原則として、あらゆる種類の水平方向の配置を避けてください。\u003c/p\u003e\n\u003ch3 id=\"span-idi-17コロンspan\"\u003e\u003cspan id=\"i-17\"\u003eコロン\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e以下のようなケースでは\u003ccode\u003e:\u003c/code\u003eの前にスペースを配置します。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e型とスーパータイプを分けるために使用される場合\u003c/li\u003e\n\u003cli\u003eスーパークラスコンストラクターまたは同じクラスの異なるコンストラクターに委任する場合\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eobject\u003c/code\u003eキーワードのあと\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e宣言とその型を区切る時に、前にスペースを入れないでください。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e:\u003c/code\u003eの後ろには常にスペースを入れてください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eabstract class Foo\u0026lt;out T : Any\u0026gt; : IFoo {\n    abstract fun foo(a: Int): T\n}\nclass FooImpl : Foo() {\n    constructor(x: String) : this(x) { /*...*/ }\n    val x = object : IFoo { /*...*/ }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-18クラスヘッダーのフォーマットspan\"\u003e\u003cspan id=\"i-18\"\u003eクラスヘッダーのフォーマット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eいくつかのプライマリコンストラクター変数を持つクラスは、一行で記述できます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass Person(id: Int, name: String)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e長いヘッダーを持つクラスは、それぞれのプライマリコンストラクター変数をインデントつきの別の行としてフォーマットしてください。また閉じかっこも新しい行にしてください。もし継承を使う場合、スーパークラスの呼び出し、または実装されたインタフェースのリストは、かっこと同じ行にしてください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name) { /*...*/ }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e複数のインタフェースの場合、スーパークラスコンストラクターの呼び出しを最初に記述して、次の行にそれぞれのインタフェースを配置しなければいけません。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name),\n    KotlinMaker { /*...*/ }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e長いスーパータイプを持つクラスの場合、コロンの後に改行を入れ、すべてのスーパータイプ名を水平に揃えます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder\u0026lt;MyFavouriteVeryLongClass\u0026gt;(),\n    SomeOtherInterface,\n    AndAnotherOne {\n    fun foo() { /*...*/ }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eクラスヘッダーが長い時に、クラスヘッダーと本文を明確に分けるには、クラスヘッダーの後に空白行を入れます（上記の例のように）。または、開き中かっこを別の行に配置します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder\u0026lt;MyFavouriteVeryLongClass\u0026gt;(),\n    SomeOtherInterface,\n    AndAnotherOne\n{\n    fun foo() { /*...*/ }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eコンストラクター変数には通常のインデント（4つのスペース）を使用します。\u003c/p\u003e\n\u003ch3 id=\"span-idi-19修飾子span\"\u003e\u003cspan id=\"i-19\"\u003e修飾子\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e宣言に複数の修飾子がある場合は、常に以下の順番で配置してください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003epublic / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation\ncompanion\ninline\ninfix\noperator\ndata\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eすべてのアノテーションは、修飾子の前にしてください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e@Named(\"Foo\")\nprivate val foo: Foo\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eライブラリで作業している場合をのぞき、冗長な修飾子は省略してください（e.g. \u003ccode\u003epublic\u003c/code\u003e）。\u003c/p\u003e\n\u003ch3 id=\"span-idi-20アノテーションフォーマットspan\"\u003e\u003cspan id=\"i-20\"\u003eアノテーションフォーマット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eアノテーションは通常、関連する宣言の前に、個別の行に置かれます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e@Target(AnnotationTarget.PROPERTY)\nannotation class JsonExclude\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e引数がない単一のアノテーションの場合、対応する宣言と同じ行に置けます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e@Test fun foo() { /*...*/ }\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-21ファイルアノテーションspan\"\u003e\u003cspan id=\"i-21\"\u003eファイルアノテーション\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e（もしあれば）ファイルアノテーションはファイルコメントの後、\u003ccode\u003epackage\u003c/code\u003eステートメントの前に配置され、\u003ccode\u003epackage\u003c/code\u003eとは空白行で区切られます。 （パッケージではなくファイルをターゲットにしているという事実を強調するために）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e/** License, copyright and whatever */\n@file:JvmName(\"FooBar\")\npackage foo.bar\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-22関数フォーマットspan\"\u003e\u003cspan id=\"i-22\"\u003e関数フォーマット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e関数のシグネチャーが一行に収まらない場合、以下のような構成を使用します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType\n): ReturnType {\n    // body\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e関数の変数には通常のインデント（4つのスペース）を使用します。\u003c/p\u003e\n\u003cp\u003e単一の式で構成される本体を持つ関数には、式本体を使用することが好まれます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun foo(): Int {     // bad\n    return 1\n}\nfun foo() = 1        // good\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-23式本体のフォーマットspan\"\u003e\u003cspan id=\"i-23\"\u003e式本体のフォーマット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e式本体を持つ関数が一行で収まらない場合、一行目に\u003ccode\u003e=\u003c/code\u003eを配置し、式の本文を4つのスペースでインデントします。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun f(x: String) =\n    x.length\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-24プロパティのフォーマットspan\"\u003e\u003cspan id=\"i-24\"\u003eプロパティのフォーマット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eとてもシンプルな読み取り専用プロパティの場合、一行のフォーマットを検討してください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eval isEmpty: Boolean get() = size == 0\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eそれ以上に複雑なプロパティの場合、\u003ccode\u003eget\u003c/code\u003eや\u003ccode\u003eset\u003c/code\u003eを別の行に配置します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eval foo: String\n    get() { /*...*/ }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eイニシャライザーを持つプロパティを持ち、イニシャライザーが長い場合、イコールの後に改行を追加し、4つのスペースでインデントします。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eprivate val defaultCharset: Charset? =\n    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-25制御フローステートメントのフォーマッットspan\"\u003e\u003cspan id=\"i-25\"\u003e制御フローステートメントのフォーマッット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eもし\u003ccode\u003eif\u003c/code\u003eや\u003ccode\u003ewhen\u003c/code\u003eのステートメントの条件が複数行の場合、ステートメントの本文は中かっこで囲います。条件の後続行を、ステートメント開始に対して4つスペースでインデントします。条件の閉じかっこと開き中かっこを、別の行に配置します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eif (!component.isSyncing \u0026\u0026\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e理由 : きちんと整列させるため、そして条件とステートメント本体との明確の分離のため\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eelse\u003c/code\u003e, \u003ccode\u003ecatch\u003c/code\u003e, \u003ccode\u003efinall\u003c/code\u003eキーワード、およびdo/whileループの\u003ccode\u003ewhile\u003c/code\u003eキーワードを、前の中かっこと同じ行に配置します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eif (condition) {\n    // body\n} else {\n    // else part\n}\ntry {\n    // body\n} finally {\n    // cleanup\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ewhen\u003c/code\u003eステートメント内では、分岐が1行以上なら、隣接したケースブロックと空白行で分離することを検討してください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eprivate fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken -\u0026gt;\n            callback.visitValue(propName, token.value)\n        Token.LBRACE -\u0026gt; { // ...\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e短い分岐をなら、中かっこなしで、条件と同じ行に配置します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003ewhen (foo) {\n    true -\u0026gt; bar() // good\n    false -\u0026gt; { baz() } // bad\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-26メソッド呼び出しのフォーマットspan\"\u003e\u003cspan id=\"i-26\"\u003eメソッド呼び出しのフォーマット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e長い引数リストでは、開きかっこの後に空行を入れます。引数を4つのスペースでインデントします。複数の密接に関連する引数をグループ化します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003edrawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e=\u003c/code\u003eサインのまわりにスペースを配置し、引数名と値を分離します。\u003c/p\u003e\n\u003ch3 id=\"span-idi-27チェイン呼び出しのラッピングspan\"\u003e\u003cspan id=\"i-27\"\u003eチェイン呼び出しのラッピング\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eチェイン呼び出しをラップする場合、\u003ccode\u003e.\u003c/code\u003e記号や\u003ccode\u003e?.\u003c/code\u003e演算子を単一のインデントと共に、次の行に配置します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eval anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-28ラムダフォーマットspan\"\u003e\u003cspan id=\"i-28\"\u003eラムダフォーマット\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eラムダ式では、中かっこの周りだけではなく、パラメーターとボディを分離するために矢印のまわりにもスペースを使用する必要があります。もし呼び出しが単一のラムダをとる場合、可能な限りかっこの外に渡す必要があります。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003elist.filter { it \u0026gt; 10 }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eラムダにラベルを付与する場合、ラベルと開き中かっこの間にスペースを開けてはいけません。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun foo() {\n    ints.forEach lit@{\n        // ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e複数行のラムダで変数名を宣言する場合、最初の行に名前を置き、矢印、そして改行します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eappendCommaSeparated(properties) { prop -\u0026gt;\n    val propertyValue = prop.get(obj)  // ...\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e変数名のリストが長すぎて1行に収まらない場合、矢印を別の行に配置します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efoo {\n   context: Context,\n   environment: Env\n   -\u0026gt;\n   context.configureEnv(environment)\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"span-idi-29ドキュメントコメントspan\"\u003e\u003cspan id=\"i-29\"\u003eドキュメントコメント\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003eより長いドキュメントコメントの場合は、開始の\u003ccode\u003e/*\u003c/code\u003eを別の行に配置し、後続の各行をアスタリスクで始めます\u003cbr\u003e\n。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e/**\n * これは複数行の場合の\n * ドキュメンテーションコメントです。\n */\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e短いコメントは一行で配置できます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e /** これは短いドキュメンテーションコメントです。 */\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一般に、\u003ccode\u003e@param\u003c/code\u003eや\u003ccode\u003e@return\u003c/code\u003eタグの使用は避けてください。代わりに、変数の説明と返り値をドキュメントコメントに直接組み込んで、言及されている場所にリンクを追加します。\u003ccode\u003e@param\u003c/code\u003eや\u003ccode\u003e@return\u003c/code\u003eは、本文の流れにフィットしない長い説明が必要な場合だけ使用してください。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e// Avoid doing this:\n/**\n * Returns the absolute value of the given number.\n * @param number The number to return the absolute value for.\n * @return The absolute value.\n */\nfun abs(number: Int) { /*...*/ }\n// Do this instead:\n/**\n * Returns the absolute value of the given [number].\n */\nfun abs(number: Int) { /*...*/ }\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"span-idi-30冗長な構造の回避span\"\u003e\u003cspan id=\"i-30\"\u003e冗長な構造の回避\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e一般にKotlinの特定のシンタックス構造が任意で、IDEによって冗長として強調表現されたら、それをコードから取り除かなければいけません。「明確にするため」として不要なシンタックス要素を残さないでください。\u003c/p\u003e\n\u003ch3 id=\"span-idunitunitspan\"\u003e\u003cspan id=\"Unit\"\u003eUnit\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e関数がUnitを返す場合、返り値型を省略する必要があります。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun foo() { // \": Unit\" が省略されている\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-31セミコロンspan\"\u003e\u003cspan id=\"i-31\"\u003eセミコロン\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e可能な限りセミコロンを省略します。\u003c/p\u003e\n\u003ch3 id=\"span-idstringstringテンプレートspan\"\u003e\u003cspan id=\"String\"\u003eStringテンプレート\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e単純な変数を文字列テンプレートに挿入する場合は、中かっこを使用しないでください。長い式にのみ、中かっこを使用します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eprintln(\"$name has ${children.size} children\")\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"span-idkotlinkotlinらしい書き方span\"\u003e\u003cspan id=\"Kotlin\"\u003eKotlinらしい書き方\u003c/span\u003e\u003c/h2\u003e\n\u003ch3 id=\"span-idi-32不変性span\"\u003e\u003cspan id=\"i-32\"\u003e不変性\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e可変よりも不変のデータを使用すること選びます。初期化した後に変更しない場合、ローカル変数とプロパティは常に\u003ccode\u003evar\u003c/code\u003eよりも\u003ccode\u003eval\u003c/code\u003eを使用します。変更しない場合、コレクションを宣言するときは不変なコレクションインタフェース（\u003ccode\u003eCollection\u003c/code\u003e, \u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e, \u003ccode\u003eMap\u003c/code\u003e）を常に使用します。\u003cbr\u003e\nコレクションインスタンスを生成するためにファクトリー関数を使用する場合、可能な限り不変なコレクション型を返す関数を使用します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e// 悪い: 変更されない値に対して可変コレクションを使用している\nfun validateValue(actualValue: String, allowedValues: HashSet\u0026lt;String\u0026gt;) { ... }\n// 良い: 不変のコレクションを使用する\nfun validateValue(actualValue: String, allowedValues: Set\u0026lt;String\u0026gt;) { ... }\n// 悪い: arrayListOf() は ArrayList\u0026lt;T\u0026gt; を返す、これは可変のコレクション型です\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n// 良い: listOf() は List\u0026lt;T\u0026gt; を返す\nval allowedValues = listOf(\"a\", \"b\", \"c\")\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-33デフォルトのパラメーター値span\"\u003e\u003cspan id=\"i-33\"\u003eデフォルトのパラメーター値\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eオーバーロードされた関数を宣言するよりも、デフォルトパラメーターを持つ関数を宣言することをオススメします。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003e// 悪い\nfun foo() = foo(\"a\")\nfun foo(a: String) { /*...*/ }\n// 良い\nfun foo(a: String = \"a\") { /*...*/ }\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-34型エイリアスspan\"\u003e\u003cspan id=\"i-34\"\u003e型エイリアス\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e関数型またはコードベースで複数回使用される型パラメーターを持つ型がある場合、その型エイリアスを定義することをオススメします。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003etypealias MouseClickHandler = (Any, MouseEvent) -\u0026gt; Unit\ntypealias PersonIndex = Map\u0026lt;String, Person\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-35ラムダパラメーターspan\"\u003e\u003cspan id=\"i-35\"\u003eラムダパラメーター\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eラムダ内で、短くてネストしていない場合は、パラメーターを明示的に宣言する代わりに、\u003ccode\u003eit\u003c/code\u003e規則を使用することをオススメします。パラメーターを持つラムダの場合、パラメーターは明示的に宣言するべきです。\u003c/p\u003e\n\u003ch3 id=\"span-idi-36ラムダにおけるリターンspan\"\u003e\u003cspan id=\"i-36\"\u003eラムダにおけるリターン\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eラムダで複数のラベルつきリターンを使用しないでください。ラムダが単一の終点を持つように再構築することを検討してください。\u003cbr\u003e\nそれが不可能または十分に明確でない場合は、ラムダを匿名関数に変換することを検討してください。\u003c/p\u003e\n\u003cp\u003eラムダの最後のステートメントにラベル付きリターンを使用しないでください。\u003c/p\u003e\n\u003ch3 id=\"span-idi-37名前付き引数span\"\u003e\u003cspan id=\"i-37\"\u003e名前付き引数\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eメソッドが同じプリミティブ型の複数のパラメーターを取る場合、またはブール型のパラメーターの場合、文脈からすべてのパラメーターの意味が完全に明確でない限り、名前付き引数構文を使用します。\u003c/p\u003e\n\u003ch3 id=\"span-idi-38条件文を使用するspan\"\u003e\u003cspan id=\"i-38\"\u003e条件文を使用する\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003ewhen\u003c/code\u003eで式形式を使用することをオススメします。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003ereturn if (x) foo() else bar()\nreturn when(x) {\n    0 -\u0026gt; \"zero\"\n    else -\u0026gt; \"nonzero\"\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上記は、以下よりも好ましいです。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eif (x)\n    return foo()\nelse\n    return bar()\nwhen(x) {\n    0 -\u0026gt; return \"zero\"\n    else -\u0026gt; return \"nonzero\"\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idifwhenif対whenspan\"\u003e\u003cspan id=\"ifwhen\"\u003eif対when\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e2値条件では\u003ccode\u003ewhen\u003c/code\u003eよりも\u003ccode\u003eif\u003c/code\u003eが好ましいです。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003ewhen (x) {\n    null -\u0026gt; // ...\n    else -\u0026gt; // ...\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eよりも、\u003ccode\u003eif (x == null) ... else ...\u003c/code\u003eを使用します。\u003c/p\u003e\n\u003cp\u003e3つ以上の選択肢がある場合は、\u003ccode\u003ewhen\u003c/code\u003eを使用します。\u003c/p\u003e\n\u003ch3 id=\"span-idnullboolean条件でnull許容なbooleanを使用するspan\"\u003e\u003cspan id=\"nullBoolean\"\u003e条件でnull許容なBooleanを使用する\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e条件式で、null許容な\u003ccode\u003eBoolean\u003c/code\u003eを使用する必要がある場合、\u003ccode\u003eif (value == true)\u003c/code\u003eまたは\u003ccode\u003eif (value == false)\u003c/code\u003eチェックを使用します。\u003c/p\u003e\n\u003ch3 id=\"span-idi-39ループを使用するspan\"\u003e\u003cspan id=\"i-39\"\u003eループを使用する\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eループには、（\u003ccode\u003efilter\u003c/code\u003e, \u003ccode\u003emap\u003c/code\u003e）などの高階関数を使用することを推奨します。例外：\u003ccode\u003eforEach\u003c/code\u003e（\u003ccode\u003eforEach\u003c/code\u003eのレシーバーがnull許容か、長いコールチェインの一部として使用されている場合以外は、通常の\u003ccode\u003efor\u003c/code\u003eループを使用することを推奨します）。\u003c/p\u003e\n\u003cp\u003e複数の高階関数とループを使った複雑な式を選択する場合、それぞれの場合に実行される操作のコストと、パフォーマンスの考慮事項に留意することを理解してください。\u003c/p\u003e\n\u003ch3 id=\"span-idi-40範囲のループspan\"\u003e\u003cspan id=\"i-40\"\u003e範囲のループ\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003euntil\u003c/code\u003eを使って、オープン範囲でループします。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efor (i in 0..n - 1) { /*...*/ }  // 悪い\nfor (i in 0 until n) { /*...*/ }  // 悪い\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idstringstringを使用するspan\"\u003e\u003cspan id=\"string\"\u003estringを使用する\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e文字列の結合よりも、文字列テンプレートを使用することを推奨します。\u003c/p\u003e\n\u003cp\u003e通常の文字列リテラルに\u003ccode\u003e\\n\u003c/code\u003eエスケープシーケンスを埋め込むよりも、複数行の文字列を使用することをオススメします。\u003c/p\u003e\n\u003cp\u003e複数行の文字列でインデントを維持するため、結果の文字列が内部インデントを必要としない場合\u003ccode\u003etrimIndent\u003c/code\u003eを使用し、内部インデントが必要な場合は\u003ccode\u003etrimMargin\u003c/code\u003eを使用します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eassertEquals(\n    \"\"\"\n    Foo\n    Bar\n    \"\"\".trimIndent(),\n    value\n)\nval a = \"\"\"if(a \u0026gt; 1) {\n          |    return a\n          |}\"\"\".trimMargin()\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-41関数かプロパティかspan\"\u003e\u003cspan id=\"i-41\"\u003e関数かプロパティか\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eいくつかのケースで、引数なしの関数は読み取り専用のプロパティに変更可能かもしれません。意味的には同じですが、どちらかを優先するかについて、いくつかのスタイル上の規則があります。\u003c/p\u003e\n\u003cp\u003e以下のアルゴリズムの場合、関数よりもプロパティを優先します。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethrowしない\u003c/li\u003e\n\u003cli\u003e計算コストが低い（または最初の実行でキャッシュされる）\u003c/li\u003e\n\u003cli\u003eオブジェクトの状態が変わらない場合、呼び出しに対して同じ結果を返す\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"span-idi-42拡張関数を使用するspan\"\u003e\u003cspan id=\"i-42\"\u003e拡張関数を使用する\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e積極的に拡張関数を使用します。主にオブジェクトで機能する関数がある都度、そのオブジェクトをレシーバーとして受け入れる拡張関数にすることを検討してください。APIの汚染を再宣言にするためにも、意味のある限り拡張関数の可視性を制限します。必要の応じて、ローカル拡張関数、メンバー拡張関数、もしくはプライベート可視性のトップレベル拡張関数を使用します。\u003c/p\u003e\n\u003ch3 id=\"span-idi-43中置関数を使用するspan\"\u003e\u003cspan id=\"i-43\"\u003e中置関数を使用する\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e2つのオブジェクトが同様の役割で機能する場合、関数を中置として宣言します。良い例が\u003ccode\u003eand\u003c/code\u003e, \u003ccode\u003eto\u003c/code\u003e, \u003ccode\u003ezip\u003c/code\u003e。悪い例が\u003ccode\u003eadd\u003c/code\u003eです。\u003c/p\u003e\n\u003cp\u003eレシーバーオブジェクトに変化する場合は、メソッドを中置として宣言してはいけません。\u003c/p\u003e\n\u003ch3 id=\"span-idi-44ファクトリー関数span\"\u003e\u003cspan id=\"i-44\"\u003eファクトリー関数\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eクラスのファクトリー関数を宣言する場合、クラス同じ名前を与えることを避けてください。ファクトリー関数のふるまいが特別であることを明確にするため、明確な名前をつけることを優先してください。\u003c/p\u003e\n\u003cp\u003e例:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass Point(val x: Double, val y: Double) {\n    companion object {\n        fun fromPolar(angle: Double, radius: Double) = Point(...)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eオブジェクトが異なるスーパークラスを呼び出さない複数のオーバーロードされたコンストラクターを持つ場合。そしてデフォルト引数値を持つ単一のコンストラクターを減らせないとき、オーバーロードコンストラクターをファクトリ関数に置き換えることをオススメします。\u003c/p\u003e\n\u003ch3 id=\"span-idi-45プラットフォーム型span\"\u003e\u003cspan id=\"i-45\"\u003eプラットフォーム型\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003epublicな関数やメソッドがプラットフォームの式を返す場合、それのKotlinタイプを明確に宣言しなければならない。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun apiCall(): String = MyJavaApi.getProperty(\"name\")\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eプラットフォームの式で初期化された（パッケージレベルかクラスレベルの）プロパティは、それのKotlinの型で明確に宣言しなければいけません。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eclass Person {\n    val name: String = MyJavaApi.getProperty(\"name\")\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eプラットフォーム型で初期化されたローカル値は、型宣言がある場合と、ない場合があります。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003efun main() {\n    val name = MyJavaApi.getProperty(\"name\")\n    println(name)\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"span-idi-46スコープ関数の使用span\"\u003e\u003cspan id=\"i-46\"\u003eスコープ関数の使用\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003eKotlinでは特定のオブジェクトのコンテキストでコードのブロックを実行するためのさまざまな機能を提供します。\u003ccode\u003elet\u003c/code\u003e ,\u003ccode\u003erun\u003c/code\u003e, \u003ccode\u003ewith\u003c/code\u003e, \u003ccode\u003eapply\u003c/code\u003e, そして\u003ccode\u003ealso\u003c/code\u003e。ケースに適したスコープ関数を選択するためのガイダンスについては、\u003ca href=\"https://kotlinlang.org/docs/reference/scope-functions.html\"\u003eスコープ関数\u003c/a\u003eを参照してください。\u003c/p\u003e\n\u003ch2 id=\"span-idi-47ライブラリでのコーディング規約span\"\u003e\u003cspan id=\"i-47\"\u003eライブラリでのコーディング規約\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003eライブラリを作成するときは、APIの安定性を確保するために、追加のルールセットに従うことをオススメします。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eメンバーの可視性を常に明示します（誤って宣言をpublic APIとして公開しないようにするため）\u003c/li\u003e\n\u003cli\u003e常に関数の返り型と引数型を明示します（実装の変更によって偶発的に返り値型が変わることを避けるために）\u003c/li\u003e\n\u003cli\u003e新しいドキュメントを必要としないオーバーライドをのぞきすべてのpublicメンバーでKDocを提供します（ライブラリのドキュメント生成をサポートするために）\u003c/li\u003e\n\u003c/ul\u003e"}</script><link rel=preload as=script href="/bundle.js?v=1613305790"></head><body><header id=nav class=header><div class="ax-l-i max-w-6xl"><div class=ax-logo><a class=block href=/ title="yutaka0m blog"><span class="font-semibold text-raven-900">yutaka0m blog</span></a></div><div class=ax-user><a class="p-2 w-8 h-8 block text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" target=_blank rel="noopener nofollow" href="https://www.google.com/search?q=site:https://tech.yutaka0m.com" title=Search><svg class="fill-current" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.67 12.804c0-5.6 4.544-10.134 10.133-10.134s10.134 4.544 10.134 10.134-4.544 10.133-10.134 10.133S2.67 18.393 2.67 12.804zm28.943 16.923-8.868-8.868c4.287-5.3 3.68-13.012-1.378-17.57S8.564-1.066 3.75 3.75s-5.017 12.558-.46 17.618 12.28 5.665 17.57 1.378l8.868 8.868a1.33 1.33.0 002.231-.597c.123-.46-.008-.952-.345-1.29h0z"/></svg></a><a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href=/entry/>記事一覧</a></div></div></header><main><div class=default-single><div class="ax-title ax-l-o"><div class="ax-l-i max-w-680"><h1 class="post-title font-content-title font-normal leading-tight tracking-default text-40">Kotlinコーディング規約</h1><div class="ax-meta flex items-center mt-5"><div class="flex-grow min-w-0"><div class="flex items-center"><div class=flex-shrink-0><img class="w-12 h-12 sm:w-14 sm:h-14 object-cover p-3px rounded-full border border-blue-300" src=/image/author/default.jpg alt=yutaka0m></div><div class="flex-shrink-0 ml-2 leading-tight font-content-sans"><a class="block text-sm text-raven-800 hover:text-raven-900 hover:underline focus:underline" target=_blank rel="noopener nofollow" title=yutaka0m href=https://tech.yutaka0m.com>yutaka0m</a>
<time class="text-sm text-raven-500" datetime=2020-01-25T08:30:22Z>Jan 25, 2020 8:30AM</time></div></div></div><div><div class="flex items-center"><a class="flex-shrink-0 block text-raven-800 hover:text-raven-900" target=_blank rel="noopener nofollow" title="Share on Twitter" href="https://twitter.com/intent/tweet?text=Kotlin%e3%82%b3%e3%83%bc%e3%83%87%e3%82%a3%e3%83%b3%e3%82%b0%e8%a6%8f%e7%b4%84%20by%20%40yutaka0m%20https%3a%2f%2ftech.yutaka0m.com%2fentry%2f2020%2f01%2f25%2f13%2f"><svg class="w-6 h-6 fill-current" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11.0 01-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56.0 00-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57.0 002.914 5.452 6.48 6.48.0 01-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42.0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18.0 01-8.134 2.798c-.538.0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072.0 18.672-10 18.672-18.668.0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg></a><a class="ml-3 flex-shrink-0 block text-raven-800 hover:text-raven-900" target=_blank rel="noopener nofollow" title="Share on Facebook" href="https://www.facebook.com/dialog/share?app_id=&display=page&href=https%3a%2f%2ftech.yutaka0m.com%2fentry%2f2020%2f01%2f25%2f13%2f"><svg class="w-6 h-6 fill-current" viewBox="-7 -3.5 39 39" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M30.234.0H1.765C.8.001.0.79.0 1.766v28.47C.001 31.2.79 32 1.766 32h15.328V19.625h-4.156V14.78h4.156v-3.564c0-4.134 2.523-6.384 6.21-6.384 1.766.0 3.284.13 3.726.2v4.32h-2.543c-2.006.0-2.394.953-2.394 2.352v3.085h4.797l-.625 4.844h-4.172V32h8.14C31.21 32 32 31.2 32 30.234V1.765C32 .8 31.21.0 30.234.0z"/></svg></a></div></div></div></div></div><div class="ax-content ax-l-o"><div class="ax-l-i max-w-680"><article class=cdata><p>この記事は <a href=http://kotlinlang.org/>http://kotlinlang.org/</a> の<a href=https://kotlinlang.org/docs/reference/coding-conventions.html>Coding Conventions</a>を日本語に翻訳したものです。<br>原文は2020年1月2日時点のものを参照しています。</p><p><a href=http://kotlinlang.org/>http://kotlinlang.org/</a> は <a href=https://github.com/JetBrains/kotlin-web-site/blob/master/LICENSE>Apache License 2.0</a>です。<br><a href=https://github.com/JetBrains/kotlin-web-site/blob/master/pages/contribute.md#translations>GitHub</a>には「母国語に翻訳してWebに公開してよい」と記載されています。</p><h2 id=span-idiコーディング規約span><span id=i>コーディング規約</span></h2><p>このページでは、Kotlinのための一般的なコーディングスタイルについて紹介します。</p><ul><li>ソースコードの構成</li><li>命名規則</li><li>フォーマット</li><li>ドキュメントコメント</li><li>冗長な構造の回避</li><li>Kotlinらしい書き方</li><li>ライブラリでのコーディング規約</li></ul><h3 id=span-idi-2スタイルガイドを適用するspan><span id=i-2>スタイルガイドを適用する</span></h3><p>このスタイルガイドと一致するをIntelliJのフォーマッターを設定するには、Kotlin pluginのバージョン1.2.20以降をインストール。<strong>Settings</strong> -> <strong>Editor</strong> -> <strong>Code Style</strong> -> <strong>Kotlin</strong>で、上部右端の**Set from…**をクリック。<strong>Predefined style</strong> -> <strong>Kotlin style guide</strong>をメニューから選択します。</p><p>コードがスタイルガイドに剃ってフォーマットされていることを確認できます。そのためには、<strong>Kotlin</strong>-><strong>Style issues</strong>-><strong>File is not formatted according to project settings</strong>を有効にします。</p><p>スタイルガイドに他の問題（命名規則など）を検討する追加のインスペクションはデフォルトで有効になっています。</p><h2 id=span-idi-3ソースコードの構成span><span id=i-3>ソースコードの構成</span></h2><h3 id=span-idi-4ディレクトリ構造span><span id=i-4>ディレクトリ構造</span></h3><p>純粋なKotlinプロジェクトでは、推奨されるディレクトリ構造は共通ルートパッケージが省略したパッケージ構造に従います。たとえば、プロジェクト内のすべてのコードが<code>org.example.kotlin</code>パッケージとそのサブパッケージである場合。<code>org.example.kotlin</code>パッケージを持つファイルは、ソースルート配下におかなければいけません。そして<code>org.example.kotlin.network.socket</code>のファイルはソースルートの<code>network/socket</code>サブディレクトリにある必要があります。</p><blockquote><p><strong><em>JVMにおいて</em></strong>: KotlinがJavaと一緒に使用されるプロジェクトにおいては、Kotlinのソースファイルは、Javaソースファイルと同じソースルートに存在する必要があり、同じディレクトリ構造に従います（それぞれのファイルは、各パッケージ文に対応するディレクトリ内に存在する必要があります。）</p></blockquote><h3 id=span-idi-5ソースファイル名span><span id=i-5>ソースファイル名</span></h3><p>もし、Kotlinファイルに1つのクラスだけが含まれる場合、ファイル名は<code>.kt</code>拡張子を加えたクラスメイト同じにしなければいけません。もしファイルに複数のクラスやトップレベル宣言だけの場合、ファイルの内容を説明する適切な名前をつけましょう。最初の文字が大文字のキャメルケースを使ってください（たとえば、<code>ProcessDeclarations.kt</code>）</p><p>ファイル名はそのファイルの中のコードがやっていること説明する必要があります。それゆえ、"Uitl”のような無意味な言葉を避けるべきです。</p><h3 id=span-idi-6ソースファイル構成span><span id=i-6>ソースファイル構成</span></h3><p>宣言に意味的に密接な関係があって、ファイルサイズが適切な範囲内（数百行を超えない）である限り、同一のKotlinソースファイル内に複数の宣言を配置することは推奨されます。</p><p>とくに、あるクラスのすべてのクライアントに関連する拡張関数を定義するとき、クラス自体が定義されているファイルと同じところに書きます。特定のクライアントに対してのみ意味のある拡張関数を定義する場合、それらをクライアントに続いて記述します。決して、"Fooのすべての拡張子”を持つだけのファイルを作ってはいけない。</p><h3 id=span-idi-7クラスレイアウトspan><span id=i-7>クラスレイアウト</span></h3><p>一般に、クラスの中身は、以下のような順番でソートされている。</p><ul><li>プロパティ宣言とinitializerブロック</li><li>セカンダリーコンストラクター</li><li>メソッド宣言</li><li>コンパニオン　オブジェクト</li></ul><p>メソッドをアルファベット順や見やすさでソートしないでください、そして、普通のメソッドを拡張メソッドと分けないでください。それよりも、クラスを上から下に読んだとき、何が起きているかを理論的に追うことができるような順番にします。順序を選択し（最初に高レベルのもの、またはその逆）、それを遵守します。</p><p>ネストされたクラスは、そららのクラスを使用するコードの隣に配置します。もしクラスが外部から使用されることが想定され、クラス内で参照されない場合、それは最後（コンパニオンオブジェクトの後ろ）に配置します。</p><h3 id=span-idi-8インタフェース実装レイアウトspan><span id=i-8>インタフェース実装レイアウト</span></h3><p>インタフェースを実装する場合、実装メンバーをインタフェースメンバーと同じ順番にします。</p><h3 id=span-idi-9オーバーロードレイアウトspan><span id=i-9>オーバーロードレイアウト</span></h3><p>常にオーバーロードを隣どうしに配置します。</p><h2 id=span-idi-10命名規則span><span id=i-10>命名規則</span></h2><p>Kotlinにおけるパッケージとクラスの命名ルールはとてもシンプルです。</p><ul><li><p>パッケージ名は常にローワーケースで、アンダースコアを使用してはいけません（<code>org.example.project</code>）。<br>通常、複数語の名前は推奨されませんが、複数語を使用する必要があるときは、単純にくっつけるかキャメルケースを使用します（<code>org.example.myProject</code>）。</p></li><li><p>クラスやオブジェクト名は大文字で始めて、キャメルケースを使用します。</p></li></ul><pre><code class=language-kotlin>open class DeclarationProcessor { /*...*/ }
object EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }</code></pre><h3 id=span-idi-11関数名span><span id=i-11>関数名</span></h3><p>関数、プロパティ、ローカル変数の名前は小文字から始まり、キャメルケースを使って、アンダースコアは使ってはいけません。</p><pre><code class=language-kotlin>fun processDeclarations() { /*...*/ }
var declarationCount = 1</code></pre><p>例外：インスタンスを生成するファクトリー関数は、作成されるクラスと同じ名前を持つことができます。</p><pre><code class=language-kotlin>abstract class Foo { /*...*/ }
class FooImpl : Foo { /*...*/ }
fun FooImpl(): Foo { return FooImpl() }</code></pre><h3 id=span-idi-12テストメソッドの名前span><span id=i-12>テストメソッドの名前</span></h3><p>テストでは、バッククォートで囲われた中では、スペースを含むメソッド名を使用することが許容されます。メソッド名にアンダースコアを使うのもテストコードでは許されます。</p><pre><code class=language-kotlin>class MyTestCase {
     @Test fun &lt;code>ensure everything works</code>() { /*...*/ }
     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }
}&lt;/code></pre><h3 id=span-idi-13プロパティ名span><span id=i-13>プロパティ名</span></h3><p>定数名（<code>const</code>でマークされたプロパティ、またはトップレベル、またはイミュータブルなデータを保持するカスタム<code>get</code>関数がない<code>val</code>プロパティ）。 は大文字のアンダースコアで区切られた名前を使用しなくてはいけません。</p><pre><code class=language-kotlin>const val MAX_COUNT = 8
val USER_NAME_FIELD = "UserName"</code></pre><p>ふるまい、または変更可能（ミュータブル）なデータを持つトップレベルかオブジェクトプロパティーの名前は、キャメルケースを使用する必要があります。</p><pre><code class=language-kotlin>val mutableCollection: MutableSet&lt;String&gt; = HashSet()</code></pre><p>enum定数の場合、アンダースコアで区切られた大文字（<code>enum class Color { RED, GREEN }</code>）か、大文字で始まるキャメルケースを使用できますので、用途に合わせて使ってください。</p><h4 id=バッキングプロパティの名前>バッキングプロパティの名前</h4><p>もしクラス内に、概念的には同じ2つのプロパティで、一方はパブリックなAPIでもう一方は実装の詳細である場合、プライベートプロパティの名前の先頭にアンダースコアをつけることできます。</p><pre><code class=language-kotlin>class C {
    private val _elementList = mutableListOf&lt;Element&gt;()
    val elementList: List&lt;Element&gt;
         get() = _elementList
}</code></pre><h3 id=span-idi-14よい名前を選ぶspan><span id=i-14>よい名前を選ぶ</span></h3><p>クラス名は通常クラスが何者であるかを示す名詞か名詞句です：<code>List</code>, <code>PersonReader</code>。</p><p>メソッド名は通常メソッドが何をするかを述べる動詞か動詞句です:<code>close</code>, <code>readPersons</code>。また名前は、メソッドがオブジェクトを変更するか、新しいオブジェクトを返すかを示す必要があります。たとえば、<code>sort</code>はコレクションを所定の位置に並び替え、<code>sorted</code>はコレクションを並び変えたコピーを返します。</p><p>名前はエンティティ（実態）の目的を明確にする必要があるので、（<code>Manager</code>, <code>Wrapper</code>）などの意味のない言葉を使用することを避けるのがベストです。</p><p>宣言名の一部として頭文字を使用する場合、2文字の場合は大文字にします（<code>IOStream</code>）。それ以上の長さの場合は最初の文字だけ大文字にします（<code>XmlFormatter</code>, <code>HttpInputStream</code>）。</p><h2 id=span-idi-15フォーマットspan><span id=i-15>フォーマット</span></h2><p>インデントはタブではなく、4文字のスペースを使用します。</p><p>中カッコは、構造を開始する行の終わりに開き中かっこを配置します。閉じかっこは、かっこの開始行と同じ縦ラインに記述します。</p><pre><code class=language-kotlin>if (elements != null) {
    for (element in elements) {
        // ...
    }
}</code></pre><h3 id=span-idi-16水平の空白span><span id=i-16>水平の空白</span></h3><p>2項演算子のまわりにはスペースを配置します（<code>a + b</code>）。例外："range to"演算子のまわりにはスペースを入れないでください（<code>0..i</code>）。</p><p>単項演算子のまわりにはスペースを入れないでください（<code>a++</code>）。</p><p>制御フローキーワード（<code>if</code>, <code>when</code>, <code>for</code>, <code>while</code>）の間にスペースと、対応する開きかっこを配置します。</p><p>プライマリコンストラクター宣言、メソッド宣言、メソッド呼び出しの前開きかっこの前にスペースを入れないでください。</p><pre><code class=language-kotlin>class A(val x: Int)
fun foo(x: Int) { ... }
fun bar() {
    foo(1)
}</code></pre><p><code>(</code>, <code>[</code>の後ろ、または<code>)</code>, <code>]</code>の前にスペースを入れないでください。</p><p><code>.</code>または<code>?.</code>のまわりにスペースを入れないでください（<code>foo.bar().filter { it > 2 }.joinToString()</code>, <code>foo?.bar()</code>）。</p><p><code>//</code>の後ろにスペースを配置します（<code>// This is a comment</code>）。</p><p>型パラメーターを指定するために使う、角かっこのまわりにスペースを入れないでください<code>class Map&lt;K, V> { ... }</code>。</p><p><code>::</code>のまわりにスペースを入れないでください（<code>Foo::class</code>, <code>String::length</code>）。</p><p>null許容な型を作るときに使われる<code>?</code>の前にスペースを入れないでください（<code>String?</code>）。</p><p>原則として、あらゆる種類の水平方向の配置を避けてください。</p><h3 id=span-idi-17コロンspan><span id=i-17>コロン</span></h3><p>以下のようなケースでは<code>:</code>の前にスペースを配置します。</p><ul><li>型とスーパータイプを分けるために使用される場合</li><li>スーパークラスコンストラクターまたは同じクラスの異なるコンストラクターに委任する場合</li><li><code>object</code>キーワードのあと</li></ul><p>宣言とその型を区切る時に、前にスペースを入れないでください。</p><p><code>:</code>の後ろには常にスペースを入れてください。</p><pre><code class=language-kotlin>abstract class Foo&lt;out T : Any&gt; : IFoo {
    abstract fun foo(a: Int): T
}
class FooImpl : Foo() {
    constructor(x: String) : this(x) { /*...*/ }
    val x = object : IFoo { /*...*/ }
}</code></pre><h3 id=span-idi-18クラスヘッダーのフォーマットspan><span id=i-18>クラスヘッダーのフォーマット</span></h3><p>いくつかのプライマリコンストラクター変数を持つクラスは、一行で記述できます。</p><pre><code class=language-kotlin>class Person(id: Int, name: String)</code></pre><p>長いヘッダーを持つクラスは、それぞれのプライマリコンストラクター変数をインデントつきの別の行としてフォーマットしてください。また閉じかっこも新しい行にしてください。もし継承を使う場合、スーパークラスの呼び出し、または実装されたインタフェースのリストは、かっこと同じ行にしてください。</p><pre><code class=language-kotlin>class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name) { /*...*/ }</code></pre><p>複数のインタフェースの場合、スーパークラスコンストラクターの呼び出しを最初に記述して、次の行にそれぞれのインタフェースを配置しなければいけません。</p><pre><code class=language-kotlin>class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name),
    KotlinMaker { /*...*/ }</code></pre><p>長いスーパータイプを持つクラスの場合、コロンの後に改行を入れ、すべてのスーパータイプ名を水平に揃えます。</p><pre><code class=language-kotlin>class MyFavouriteVeryLongClassHolder :
    MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(),
    SomeOtherInterface,
    AndAnotherOne {
    fun foo() { /*...*/ }
}</code></pre><p>クラスヘッダーが長い時に、クラスヘッダーと本文を明確に分けるには、クラスヘッダーの後に空白行を入れます（上記の例のように）。または、開き中かっこを別の行に配置します。</p><pre><code class=language-kotlin>class MyFavouriteVeryLongClassHolder :
    MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(),
    SomeOtherInterface,
    AndAnotherOne
{
    fun foo() { /*...*/ }
}</code></pre><p>コンストラクター変数には通常のインデント（4つのスペース）を使用します。</p><h3 id=span-idi-19修飾子span><span id=i-19>修飾子</span></h3><p>宣言に複数の修飾子がある場合は、常に以下の順番で配置してください。</p><pre><code class=language-kotlin>public / protected / private / internal
expect / actual
final / open / abstract / sealed / const
external
override
lateinit
tailrec
vararg
suspend
inner
enum / annotation
companion
inline
infix
operator
data</code></pre><p>すべてのアノテーションは、修飾子の前にしてください。</p><pre><code class=language-kotlin>@Named("Foo")
private val foo: Foo</code></pre><p>ライブラリで作業している場合をのぞき、冗長な修飾子は省略してください（e.g. <code>public</code>）。</p><h3 id=span-idi-20アノテーションフォーマットspan><span id=i-20>アノテーションフォーマット</span></h3><p>アノテーションは通常、関連する宣言の前に、個別の行に置かれます。</p><pre><code class=language-kotlin>@Target(AnnotationTarget.PROPERTY)
annotation class JsonExclude</code></pre><p>引数がない単一のアノテーションの場合、対応する宣言と同じ行に置けます。</p><pre><code class=language-kotlin>@Test fun foo() { /*...*/ }</code></pre><h3 id=span-idi-21ファイルアノテーションspan><span id=i-21>ファイルアノテーション</span></h3><p>（もしあれば）ファイルアノテーションはファイルコメントの後、<code>package</code>ステートメントの前に配置され、<code>package</code>とは空白行で区切られます。 （パッケージではなくファイルをターゲットにしているという事実を強調するために）。</p><pre><code class=language-kotlin>/** License, copyright and whatever */
@file:JvmName("FooBar")
package foo.bar</code></pre><h3 id=span-idi-22関数フォーマットspan><span id=i-22>関数フォーマット</span></h3><p>関数のシグネチャーが一行に収まらない場合、以下のような構成を使用します。</p><pre><code class=language-kotlin>fun longMethodName(
    argument: ArgumentType = defaultValue,
    argument2: AnotherArgumentType
): ReturnType {
    // body
}</code></pre><p>関数の変数には通常のインデント（4つのスペース）を使用します。</p><p>単一の式で構成される本体を持つ関数には、式本体を使用することが好まれます。</p><pre><code class=language-kotlin>fun foo(): Int {     // bad
    return 1
}
fun foo() = 1        // good</code></pre><h3 id=span-idi-23式本体のフォーマットspan><span id=i-23>式本体のフォーマット</span></h3><p>式本体を持つ関数が一行で収まらない場合、一行目に<code>=</code>を配置し、式の本文を4つのスペースでインデントします。</p><pre><code class=language-kotlin>fun f(x: String) =
    x.length</code></pre><h3 id=span-idi-24プロパティのフォーマットspan><span id=i-24>プロパティのフォーマット</span></h3><p>とてもシンプルな読み取り専用プロパティの場合、一行のフォーマットを検討してください。</p><pre><code class=language-kotlin>val isEmpty: Boolean get() = size == 0</code></pre><p>それ以上に複雑なプロパティの場合、<code>get</code>や<code>set</code>を別の行に配置します。</p><pre><code class=language-kotlin>val foo: String
    get() { /*...*/ }</code></pre><p>イニシャライザーを持つプロパティを持ち、イニシャライザーが長い場合、イコールの後に改行を追加し、4つのスペースでインデントします。</p><pre><code class=language-kotlin>private val defaultCharset: Charset? =
    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)</code></pre><h3 id=span-idi-25制御フローステートメントのフォーマッットspan><span id=i-25>制御フローステートメントのフォーマッット</span></h3><p>もし<code>if</code>や<code>when</code>のステートメントの条件が複数行の場合、ステートメントの本文は中かっこで囲います。条件の後続行を、ステートメント開始に対して4つスペースでインデントします。条件の閉じかっこと開き中かっこを、別の行に配置します。</p><pre><code class=language-kotlin>if (!component.isSyncing &&
    !hasAnyKotlinRuntimeInScope(module)
) {
    return createKotlinNotConfiguredPanel(module)
}</code></pre><blockquote><p>理由 : きちんと整列させるため、そして条件とステートメント本体との明確の分離のため</p></blockquote><p><code>else</code>, <code>catch</code>, <code>finall</code>キーワード、およびdo/whileループの<code>while</code>キーワードを、前の中かっこと同じ行に配置します。</p><pre><code class=language-kotlin>if (condition) {
    // body
} else {
    // else part
}
try {
    // body
} finally {
    // cleanup
}</code></pre><p><code>when</code>ステートメント内では、分岐が1行以上なら、隣接したケースブロックと空白行で分離することを検討してください。</p><pre><code class=language-kotlin>private fun parsePropertyValue(propName: String, token: Token) {
    when (token) {
        is Token.ValueToken -&gt;
            callback.visitValue(propName, token.value)
        Token.LBRACE -&gt; { // ...
        }
    }
}</code></pre><p>短い分岐をなら、中かっこなしで、条件と同じ行に配置します。</p><pre><code class=language-kotlin>when (foo) {
    true -&gt; bar() // good
    false -&gt; { baz() } // bad
}</code></pre><h3 id=span-idi-26メソッド呼び出しのフォーマットspan><span id=i-26>メソッド呼び出しのフォーマット</span></h3><p>長い引数リストでは、開きかっこの後に空行を入れます。引数を4つのスペースでインデントします。複数の密接に関連する引数をグループ化します。</p><pre><code class=language-kotlin>drawSquare(
    x = 10, y = 10,
    width = 100, height = 100,
    fill = true
)</code></pre><p><code>=</code>サインのまわりにスペースを配置し、引数名と値を分離します。</p><h3 id=span-idi-27チェイン呼び出しのラッピングspan><span id=i-27>チェイン呼び出しのラッピング</span></h3><p>チェイン呼び出しをラップする場合、<code>.</code>記号や<code>?.</code>演算子を単一のインデントと共に、次の行に配置します。</p><pre><code class=language-kotlin>val anchor = owner
    ?.firstChild!!
    .siblings(forward = true)
    .dropWhile { it is PsiComment || it is PsiWhiteSpace }</code></pre><h3 id=span-idi-28ラムダフォーマットspan><span id=i-28>ラムダフォーマット</span></h3><p>ラムダ式では、中かっこの周りだけではなく、パラメーターとボディを分離するために矢印のまわりにもスペースを使用する必要があります。もし呼び出しが単一のラムダをとる場合、可能な限りかっこの外に渡す必要があります。</p><pre><code class=language-kotlin>list.filter { it &gt; 10 }</code></pre><p>ラムダにラベルを付与する場合、ラベルと開き中かっこの間にスペースを開けてはいけません。</p><pre><code class=language-kotlin>fun foo() {
    ints.forEach lit@{
        // ...
    }
}</code></pre><p>複数行のラムダで変数名を宣言する場合、最初の行に名前を置き、矢印、そして改行します。</p><pre><code class=language-kotlin>appendCommaSeparated(properties) { prop -&gt;
    val propertyValue = prop.get(obj)  // ...
}</code></pre><p>変数名のリストが長すぎて1行に収まらない場合、矢印を別の行に配置します。</p><pre><code class=language-kotlin>foo {
   context: Context,
   environment: Env
   -&gt;
   context.configureEnv(environment)
}</code></pre><h2 id=span-idi-29ドキュメントコメントspan><span id=i-29>ドキュメントコメント</span></h2><p>より長いドキュメントコメントの場合は、開始の<code>/*</code>を別の行に配置し、後続の各行をアスタリスクで始めます<br>。</p><pre><code class=language-kotlin>/**
 * これは複数行の場合の
 * ドキュメンテーションコメントです。
 */</code></pre><p>短いコメントは一行で配置できます。</p><pre><code class=language-kotlin> /** これは短いドキュメンテーションコメントです。 */</code></pre><p>一般に、<code>@param</code>や<code>@return</code>タグの使用は避けてください。代わりに、変数の説明と返り値をドキュメントコメントに直接組み込んで、言及されている場所にリンクを追加します。<code>@param</code>や<code>@return</code>は、本文の流れにフィットしない長い説明が必要な場合だけ使用してください。</p><pre><code class=language-kotlin>// Avoid doing this:
/**
 * Returns the absolute value of the given number.
 * @param number The number to return the absolute value for.
 * @return The absolute value.
 */
fun abs(number: Int) { /*...*/ }
// Do this instead:
/**
 * Returns the absolute value of the given [number].
 */
fun abs(number: Int) { /*...*/ }</code></pre><h2 id=span-idi-30冗長な構造の回避span><span id=i-30>冗長な構造の回避</span></h2><p>一般にKotlinの特定のシンタックス構造が任意で、IDEによって冗長として強調表現されたら、それをコードから取り除かなければいけません。「明確にするため」として不要なシンタックス要素を残さないでください。</p><h3 id=span-idunitunitspan><span id=Unit>Unit</span></h3><p>関数がUnitを返す場合、返り値型を省略する必要があります。</p><pre><code class=language-kotlin>fun foo() { // ": Unit" が省略されている
}</code></pre><h3 id=span-idi-31セミコロンspan><span id=i-31>セミコロン</span></h3><p>可能な限りセミコロンを省略します。</p><h3 id=span-idstringstringテンプレートspan><span id=String>Stringテンプレート</span></h3><p>単純な変数を文字列テンプレートに挿入する場合は、中かっこを使用しないでください。長い式にのみ、中かっこを使用します。</p><pre><code class=language-kotlin>println("$name has ${children.size} children")</code></pre><h2 id=span-idkotlinkotlinらしい書き方span><span id=Kotlin>Kotlinらしい書き方</span></h2><h3 id=span-idi-32不変性span><span id=i-32>不変性</span></h3><p>可変よりも不変のデータを使用すること選びます。初期化した後に変更しない場合、ローカル変数とプロパティは常に<code>var</code>よりも<code>val</code>を使用します。変更しない場合、コレクションを宣言するときは不変なコレクションインタフェース（<code>Collection</code>, <code>List</code>, <code>Set</code>, <code>Map</code>）を常に使用します。<br>コレクションインスタンスを生成するためにファクトリー関数を使用する場合、可能な限り不変なコレクション型を返す関数を使用します。</p><pre><code class=language-kotlin>// 悪い: 変更されない値に対して可変コレクションを使用している
fun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) { ... }
// 良い: 不変のコレクションを使用する
fun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) { ... }
// 悪い: arrayListOf() は ArrayList&lt;T&gt; を返す、これは可変のコレクション型です
val allowedValues = arrayListOf("a", "b", "c")
// 良い: listOf() は List&lt;T&gt; を返す
val allowedValues = listOf("a", "b", "c")</code></pre><h3 id=span-idi-33デフォルトのパラメーター値span><span id=i-33>デフォルトのパラメーター値</span></h3><p>オーバーロードされた関数を宣言するよりも、デフォルトパラメーターを持つ関数を宣言することをオススメします。</p><pre><code class=language-kotlin>// 悪い
fun foo() = foo("a")
fun foo(a: String) { /*...*/ }
// 良い
fun foo(a: String = "a") { /*...*/ }</code></pre><h3 id=span-idi-34型エイリアスspan><span id=i-34>型エイリアス</span></h3><p>関数型またはコードベースで複数回使用される型パラメーターを持つ型がある場合、その型エイリアスを定義することをオススメします。</p><pre><code class=language-kotlin>typealias MouseClickHandler = (Any, MouseEvent) -&gt; Unit
typealias PersonIndex = Map&lt;String, Person&gt;</code></pre><h3 id=span-idi-35ラムダパラメーターspan><span id=i-35>ラムダパラメーター</span></h3><p>ラムダ内で、短くてネストしていない場合は、パラメーターを明示的に宣言する代わりに、<code>it</code>規則を使用することをオススメします。パラメーターを持つラムダの場合、パラメーターは明示的に宣言するべきです。</p><h3 id=span-idi-36ラムダにおけるリターンspan><span id=i-36>ラムダにおけるリターン</span></h3><p>ラムダで複数のラベルつきリターンを使用しないでください。ラムダが単一の終点を持つように再構築することを検討してください。<br>それが不可能または十分に明確でない場合は、ラムダを匿名関数に変換することを検討してください。</p><p>ラムダの最後のステートメントにラベル付きリターンを使用しないでください。</p><h3 id=span-idi-37名前付き引数span><span id=i-37>名前付き引数</span></h3><p>メソッドが同じプリミティブ型の複数のパラメーターを取る場合、またはブール型のパラメーターの場合、文脈からすべてのパラメーターの意味が完全に明確でない限り、名前付き引数構文を使用します。</p><h3 id=span-idi-38条件文を使用するspan><span id=i-38>条件文を使用する</span></h3><p><code>try</code>, <code>if</code>, <code>when</code>で式形式を使用することをオススメします。</p><pre><code class=language-kotlin>return if (x) foo() else bar()
return when(x) {
    0 -&gt; "zero"
    else -&gt; "nonzero"
}</code></pre><p>上記は、以下よりも好ましいです。</p><pre><code class=language-kotlin>if (x)
    return foo()
else
    return bar()
when(x) {
    0 -&gt; return "zero"
    else -&gt; return "nonzero"
}</code></pre><h3 id=span-idifwhenif対whenspan><span id=ifwhen>if対when</span></h3><p>2値条件では<code>when</code>よりも<code>if</code>が好ましいです。</p><pre><code class=language-kotlin>when (x) {
    null -&gt; // ...
    else -&gt; // ...
}</code></pre><p>よりも、<code>if (x == null) ... else ...</code>を使用します。</p><p>3つ以上の選択肢がある場合は、<code>when</code>を使用します。</p><h3 id=span-idnullboolean条件でnull許容なbooleanを使用するspan><span id=nullBoolean>条件でnull許容なBooleanを使用する</span></h3><p>条件式で、null許容な<code>Boolean</code>を使用する必要がある場合、<code>if (value == true)</code>または<code>if (value == false)</code>チェックを使用します。</p><h3 id=span-idi-39ループを使用するspan><span id=i-39>ループを使用する</span></h3><p>ループには、（<code>filter</code>, <code>map</code>）などの高階関数を使用することを推奨します。例外：<code>forEach</code>（<code>forEach</code>のレシーバーがnull許容か、長いコールチェインの一部として使用されている場合以外は、通常の<code>for</code>ループを使用することを推奨します）。</p><p>複数の高階関数とループを使った複雑な式を選択する場合、それぞれの場合に実行される操作のコストと、パフォーマンスの考慮事項に留意することを理解してください。</p><h3 id=span-idi-40範囲のループspan><span id=i-40>範囲のループ</span></h3><p><code>until</code>を使って、オープン範囲でループします。</p><pre><code class=language-kotlin>for (i in 0..n - 1) { /*...*/ }  // 悪い
for (i in 0 until n) { /*...*/ }  // 悪い</code></pre><h3 id=span-idstringstringを使用するspan><span id=string>stringを使用する</span></h3><p>文字列の結合よりも、文字列テンプレートを使用することを推奨します。</p><p>通常の文字列リテラルに<code>\n</code>エスケープシーケンスを埋め込むよりも、複数行の文字列を使用することをオススメします。</p><p>複数行の文字列でインデントを維持するため、結果の文字列が内部インデントを必要としない場合<code>trimIndent</code>を使用し、内部インデントが必要な場合は<code>trimMargin</code>を使用します。</p><pre><code class=language-kotlin>assertEquals(
    """
    Foo
    Bar
    """.trimIndent(),
    value
)
val a = """if(a &gt; 1) {
          |    return a
          |}""".trimMargin()</code></pre><h3 id=span-idi-41関数かプロパティかspan><span id=i-41>関数かプロパティか</span></h3><p>いくつかのケースで、引数なしの関数は読み取り専用のプロパティに変更可能かもしれません。意味的には同じですが、どちらかを優先するかについて、いくつかのスタイル上の規則があります。</p><p>以下のアルゴリズムの場合、関数よりもプロパティを優先します。</p><ul><li>throwしない</li><li>計算コストが低い（または最初の実行でキャッシュされる）</li><li>オブジェクトの状態が変わらない場合、呼び出しに対して同じ結果を返す</li></ul><h3 id=span-idi-42拡張関数を使用するspan><span id=i-42>拡張関数を使用する</span></h3><p>積極的に拡張関数を使用します。主にオブジェクトで機能する関数がある都度、そのオブジェクトをレシーバーとして受け入れる拡張関数にすることを検討してください。APIの汚染を再宣言にするためにも、意味のある限り拡張関数の可視性を制限します。必要の応じて、ローカル拡張関数、メンバー拡張関数、もしくはプライベート可視性のトップレベル拡張関数を使用します。</p><h3 id=span-idi-43中置関数を使用するspan><span id=i-43>中置関数を使用する</span></h3><p>2つのオブジェクトが同様の役割で機能する場合、関数を中置として宣言します。良い例が<code>and</code>, <code>to</code>, <code>zip</code>。悪い例が<code>add</code>です。</p><p>レシーバーオブジェクトに変化する場合は、メソッドを中置として宣言してはいけません。</p><h3 id=span-idi-44ファクトリー関数span><span id=i-44>ファクトリー関数</span></h3><p>クラスのファクトリー関数を宣言する場合、クラス同じ名前を与えることを避けてください。ファクトリー関数のふるまいが特別であることを明確にするため、明確な名前をつけることを優先してください。</p><p>例:</p><pre><code class=language-kotlin>class Point(val x: Double, val y: Double) {
    companion object {
        fun fromPolar(angle: Double, radius: Double) = Point(...)
    }
}</code></pre><p>オブジェクトが異なるスーパークラスを呼び出さない複数のオーバーロードされたコンストラクターを持つ場合。そしてデフォルト引数値を持つ単一のコンストラクターを減らせないとき、オーバーロードコンストラクターをファクトリ関数に置き換えることをオススメします。</p><h3 id=span-idi-45プラットフォーム型span><span id=i-45>プラットフォーム型</span></h3><p>publicな関数やメソッドがプラットフォームの式を返す場合、それのKotlinタイプを明確に宣言しなければならない。</p><pre><code class=language-kotlin>fun apiCall(): String = MyJavaApi.getProperty("name")</code></pre><p>プラットフォームの式で初期化された（パッケージレベルかクラスレベルの）プロパティは、それのKotlinの型で明確に宣言しなければいけません。</p><pre><code class=language-kotlin>class Person {
    val name: String = MyJavaApi.getProperty("name")
}</code></pre><p>プラットフォーム型で初期化されたローカル値は、型宣言がある場合と、ない場合があります。</p><pre><code class=language-kotlin>fun main() {
    val name = MyJavaApi.getProperty("name")
    println(name)
}</code></pre><h3 id=span-idi-46スコープ関数の使用span><span id=i-46>スコープ関数の使用</span></h3><p>Kotlinでは特定のオブジェクトのコンテキストでコードのブロックを実行するためのさまざまな機能を提供します。<code>let</code> ,<code>run</code>, <code>with</code>, <code>apply</code>, そして<code>also</code>。ケースに適したスコープ関数を選択するためのガイダンスについては、<a href=https://kotlinlang.org/docs/reference/scope-functions.html>スコープ関数</a>を参照してください。</p><h2 id=span-idi-47ライブラリでのコーディング規約span><span id=i-47>ライブラリでのコーディング規約</span></h2><p>ライブラリを作成するときは、APIの安定性を確保するために、追加のルールセットに従うことをオススメします。</p><ul><li>メンバーの可視性を常に明示します（誤って宣言をpublic APIとして公開しないようにするため）</li><li>常に関数の返り型と引数型を明示します（実装の変更によって偶発的に返り値型が変わることを避けるために）</li><li>新しいドキュメントを必要としないオーバーライドをのぞきすべてのpublicメンバーでKDocを提供します（ライブラリのドキュメント生成をサポートするために）</li></ul></article></div></div></div></main><footer class=footer><div class="ax-l-i max-w-6xl"><nav class="flex items-center justify-center"><a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href=/entry/>記事一覧</a>
<a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href=/about/>About</a>
<a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href=/contact/>Contact</a>
<a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href=/privacy-policy/>Privacy</a></nav><div class="footer-social flex items-center justify-center mt-4"><a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target=_blank rel="noopener nofollow" title=Twitter href=https://twitter.com/yutaka0m/><svg class="fill-current" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11.0 01-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56.0 00-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57.0 002.914 5.452 6.48 6.48.0 01-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42.0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18.0 01-8.134 2.798c-.538.0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072.0 18.672-10 18.672-18.668.0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg></a><a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target=_blank rel="noopener nofollow" title=Github href=https://github.com/yutaka0m/><svg class="fill-current" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M15.998.0C7.164.0.0 7.35.0 16.417.0 23.67 4.584 29.82 10.944 31.994c.8.15 1.092-.356 1.092-.79l-.022-2.792c-4.45.99-5.4-2.202-5.4-2.202-.726-1.896-1.776-2.4-1.776-2.4-1.454-1.018.108-.998.108-.998 1.606.117 2.45 1.693 2.45 1.693 1.428 2.507 3.746 1.784 4.658 1.363.144-1.06.558-1.784 1.016-2.195-3.552-.415-7.288-1.823-7.288-8.113.0-1.792.624-3.258 1.648-4.406-.166-.415-.714-2.085.156-4.344.0.0 1.344-.44 4.4 1.683 1.276-.364 2.644-.546 4.006-.552a14.98 14.98.0 014.006.554C23.062 6.37 24.404 6.8 24.404 6.8c.872 2.26.324 3.93.16 4.344 1.026 1.148 1.644 2.614 1.644 4.406.0 6.306-3.74 7.694-7.304 8.1.574.507 1.086 1.51 1.086 3.04l-.02 4.503c0 .44.288.95 1.1.788C27.42 29.817 32 23.667 32 16.417 32 7.35 24.836.0 15.998.0z"/></svg></a></div><div class="footer-copyright text-sm text-center text-gray-500 mt-4">&#169; 2020-2021 yutaka0m blog</div><div class="text-sm sm:text-xs text-center text-gray-500 mt-2">Powered by <a href="https://www.axiomtheme.com/?utm_source=theme-footer&utm_medium=website&utm_campaign=referral">Axiom</a></div></div></footer><script src="/bundle.js?v=1613305790"></script></body></html>